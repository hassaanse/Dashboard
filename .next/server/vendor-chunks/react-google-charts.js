"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-google-charts";
exports.ids = ["vendor-chunks/react-google-charts"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-google-charts/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/react-google-charts/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chart: () => (/* binding */ Chart$1),\n/* harmony export */   GoogleDataTableColumnRoleType: () => (/* binding */ GoogleDataTableColumnRoleType),\n/* harmony export */   \"default\": () => (/* binding */ Chart)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\n/**\n * Hook to load external script.\n * @param src - Source url to load.\n * @param onLoad - Success callback.\n * @param onError - Error callback.\n */ function useLoadScript(src, onLoad, onError) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!document) {\n            return;\n        }\n        // Find script tag with same src in DOM.\n        const foundScript = document.querySelector('script[src=\"'.concat(src, '\"]'));\n        // Call onLoad if script marked as loaded.\n        if (foundScript === null || foundScript === void 0 ? void 0 : foundScript.dataset.loaded) {\n            onLoad === null || onLoad === void 0 ? void 0 : onLoad();\n            return;\n        }\n        // Create or get existed tag.\n        const script = foundScript || document.createElement(\"script\");\n        // Set src if no script was found.\n        if (!foundScript) {\n            script.src = src;\n        }\n        // Mark script as loaded on load event.\n        const onLoadWithMarker = ()=>{\n            script.dataset.loaded = \"1\";\n            onLoad === null || onLoad === void 0 ? void 0 : onLoad();\n        };\n        script.addEventListener(\"load\", onLoadWithMarker);\n        if (onError) {\n            script.addEventListener(\"error\", onError);\n        }\n        // Add to DOM if not yet added.\n        if (!foundScript) {\n            document.head.append(script);\n        }\n    }, []);\n}\n\n/**\n * Hook to load Google Charts JS API.\n * @param params - Load parameters.\n * @param [params.chartVersion] - Chart version to load.\n * @param [params.chartPackages] - Packages to load.\n * @param [params.chartLanguage] - Languages to load.\n * @param [params.mapsApiKey] - Google Maps api key.\n * @returns\n */ function useLoadGoogleCharts(param) {\n    let { chartVersion =\"current\" , chartPackages =[\n        \"corechart\",\n        \"controls\"\n    ] , chartLanguage =\"en\" , mapsApiKey  } = param;\n    const [googleCharts, setGoogleCharts] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [failed, setFailed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    useLoadScript(\"https://www.gstatic.com/charts/loader.js\", ()=>{\n        // @ts-expect-error Getting object from global namespace.\n        const google = window === null || window === void 0 ? void 0 : window.google;\n        if (!google) {\n            return;\n        }\n        google.charts.load(chartVersion, {\n            packages: chartPackages,\n            language: chartLanguage,\n            mapsApiKey\n        });\n        google.charts.setOnLoadCallback(()=>{\n            setGoogleCharts(google);\n        });\n    }, ()=>{\n        setFailed(true);\n    });\n    return [\n        googleCharts,\n        failed\n    ];\n}\n/**\n * Wrapper around useLoadGoogleCharts to use in legacy components.\n */ function LoadGoogleCharts(param) {\n    let { onLoad , onError , ...params } = param;\n    const [googleCharts, failed] = useLoadGoogleCharts(params);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (googleCharts && onLoad) {\n            onLoad(googleCharts);\n        }\n    }, [\n        googleCharts\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (failed && onError) {\n            onError();\n        }\n    }, [\n        failed\n    ]);\n    return null;\n}\n\nconst chartDefaultProps = {\n    // <DEPRECATED_PROPS>\n    legend_toggle: false,\n    // </DEPRECATED_PROPS>\n    options: {},\n    legendToggle: false,\n    getChartWrapper: ()=>{},\n    spreadSheetQueryParameters: {\n        headers: 1,\n        gid: 1\n    },\n    rootProps: {},\n    chartWrapperParams: {}\n};\n\nlet uniqueID = 0;\nconst generateUniqueID = ()=>{\n    uniqueID += 1;\n    return \"reactgooglegraph-\".concat(uniqueID);\n};\n\nconst DEFAULT_CHART_COLORS = [\n    \"#3366CC\",\n    \"#DC3912\",\n    \"#FF9900\",\n    \"#109618\",\n    \"#990099\",\n    \"#3B3EAC\",\n    \"#0099C6\",\n    \"#DD4477\",\n    \"#66AA00\",\n    \"#B82E2E\",\n    \"#316395\",\n    \"#994499\",\n    \"#22AA99\",\n    \"#AAAA11\",\n    \"#6633CC\",\n    \"#E67300\",\n    \"#8B0707\",\n    \"#329262\",\n    \"#5574A6\",\n    \"#3B3EAC\"\n];\n\nconst loadDataTableFromSpreadSheet = async function(googleViz, spreadSheetUrl) {\n    let urlParams = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return new Promise((resolve, reject)=>{\n        const headers = \"\".concat(urlParams.headers ? \"headers=\".concat(urlParams.headers) : \"headers=0\");\n        const queryString = \"\".concat(urlParams.query ? \"&tq=\".concat(encodeURIComponent(urlParams.query)) : \"\");\n        const gid = \"\".concat(urlParams.gid ? \"&gid=\".concat(urlParams.gid) : \"\");\n        const sheet = \"\".concat(urlParams.sheet ? \"&sheet=\".concat(urlParams.sheet) : \"\");\n        const access_token = \"\".concat(urlParams.access_token ? \"&access_token=\".concat(urlParams.access_token) : \"\");\n        const urlQueryString = \"\".concat(headers).concat(gid).concat(sheet).concat(queryString).concat(access_token);\n        const urlToSpreadSheet = \"\".concat(spreadSheetUrl, \"/gviz/tq?\").concat(urlQueryString); //&tq=${queryString}`;\n        const query = new googleViz.visualization.Query(urlToSpreadSheet);\n        query.send((response)=>{\n            if (response.isError()) {\n                reject(\"Error in query:  \".concat(response.getMessage(), \" \").concat(response.getDetailedMessage()));\n            } else {\n                resolve(response.getDataTable());\n            }\n        });\n    });\n};\n\nconst { Provider , Consumer  } = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(chartDefaultProps);\nconst ContextProvider = (param)=>{\n    let { children , value  } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n        value: value\n    }, children);\n};\nconst ContextConsumer = (param)=>{\n    let { render  } = param;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Consumer, null, (context)=>{\n        return render(context);\n    });\n};\n\nconst GRAY_COLOR = \"#CCCCCC\";\nclass GoogleChartDataTableInner extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    componentDidMount() {\n        this.draw(this.props);\n        window.addEventListener(\"resize\", this.onResize);\n        if (this.props.legend_toggle || this.props.legendToggle) {\n            this.listenToLegendToggle();\n        }\n    }\n    componentWillUnmount() {\n        const { google , googleChartWrapper  } = this.props;\n        window.removeEventListener(\"resize\", this.onResize);\n        google.visualization.events.removeAllListeners(googleChartWrapper);\n        if (googleChartWrapper.getChartType() === \"Timeline\") {\n            googleChartWrapper.getChart() && googleChartWrapper.getChart().clearChart();\n        }\n    }\n    componentDidUpdate() {\n        this.draw(this.props);\n    }\n    render() {\n        return null;\n    }\n    constructor(...args){\n        super(...args);\n        this.state = {\n            hiddenColumns: []\n        };\n        this.listenToLegendToggle = ()=>{\n            const { google , googleChartWrapper  } = this.props;\n            google.visualization.events.addListener(googleChartWrapper, \"select\", ()=>{\n                const chart = googleChartWrapper.getChart();\n                const selection = chart.getSelection();\n                const dataTable = googleChartWrapper.getDataTable();\n                if (selection.length === 0 || // We want to listen to when a whole row is selected. This is the case only when row === null\n                selection[0].row || !dataTable) {\n                    return;\n                }\n                const columnIndex = selection[0].column;\n                const columnID = this.getColumnID(dataTable, columnIndex);\n                if (this.state.hiddenColumns.includes(columnID)) {\n                    this.setState((state)=>({\n                            ...state,\n                            hiddenColumns: [\n                                ...state.hiddenColumns.filter((colID)=>colID !== columnID), \n                            ]\n                        }));\n                } else {\n                    this.setState((state)=>({\n                            ...state,\n                            hiddenColumns: [\n                                ...state.hiddenColumns,\n                                columnID\n                            ]\n                        }));\n                }\n            });\n        };\n        this.applyFormatters = (dataTable, formatters)=>{\n            const { google  } = this.props;\n            for (let formatter of formatters){\n                switch(formatter.type){\n                    case \"ArrowFormat\":\n                        {\n                            const vizFormatter = new google.visualization.ArrowFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"BarFormat\":\n                        {\n                            const vizFormatter = new google.visualization.BarFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"ColorFormat\":\n                        {\n                            const vizFormatter = new google.visualization.ColorFormat(formatter.options);\n                            const { ranges  } = formatter;\n                            for (let range of ranges){\n                                vizFormatter.addRange(...range);\n                            }\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"DateFormat\":\n                        {\n                            const vizFormatter = new google.visualization.DateFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"NumberFormat\":\n                        {\n                            const vizFormatter = new google.visualization.NumberFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                    case \"PatternFormat\":\n                        {\n                            const vizFormatter = new google.visualization.PatternFormat(formatter.options);\n                            vizFormatter.format(dataTable, formatter.column);\n                            break;\n                        }\n                }\n            }\n        };\n        this.getColumnID = (dataTable, columnIndex)=>{\n            return dataTable.getColumnId(columnIndex) || dataTable.getColumnLabel(columnIndex);\n        };\n        this.draw = async (param)=>{\n            let { data , diffdata , rows , columns , options , legend_toggle , legendToggle , chartType , formatters , spreadSheetUrl , spreadSheetQueryParameters  } = param;\n            const { google , googleChartWrapper  } = this.props;\n            let dataTable;\n            let chartDiff = null;\n            if (diffdata) {\n                const oldData = google.visualization.arrayToDataTable(diffdata.old);\n                const newData = google.visualization.arrayToDataTable(diffdata.new);\n                chartDiff = google.visualization[chartType].prototype.computeDiff(oldData, newData);\n            }\n            if (data) {\n                if (Array.isArray(data)) {\n                    dataTable = google.visualization.arrayToDataTable(data);\n                } else {\n                    dataTable = new google.visualization.DataTable(data);\n                }\n            } else if (rows && columns) {\n                dataTable = google.visualization.arrayToDataTable([\n                    columns,\n                    ...rows\n                ]);\n            } else if (spreadSheetUrl) {\n                dataTable = await loadDataTableFromSpreadSheet(google, spreadSheetUrl, spreadSheetQueryParameters);\n            } else {\n                dataTable = google.visualization.arrayToDataTable([]);\n            }\n            const columnCount = dataTable.getNumberOfColumns();\n            const viewColumns = Array(columnCount).fill(0).map((c, i)=>{\n                const columnID = this.getColumnID(dataTable, i);\n                if (this.state.hiddenColumns.includes(columnID)) {\n                    return {\n                        label: dataTable.getColumnLabel(i),\n                        type: dataTable.getColumnType(i),\n                        calc: ()=>null\n                    };\n                } else {\n                    return i;\n                }\n            });\n            const chart = googleChartWrapper.getChart();\n            if (googleChartWrapper.getChartType() === \"Timeline\") {\n                chart && chart.clearChart();\n            }\n            googleChartWrapper.setChartType(chartType);\n            googleChartWrapper.setOptions(options || {});\n            const viewTable = new google.visualization.DataView(dataTable);\n            viewTable.setColumns(viewColumns);\n            googleChartWrapper.setDataTable(viewTable);\n            googleChartWrapper.draw();\n            if (this.props.googleChartDashboard !== null) {\n                this.props.googleChartDashboard.draw(dataTable);\n            }\n            if (chartDiff) {\n                googleChartWrapper.setDataTable(chartDiff);\n                googleChartWrapper.draw();\n            }\n            if (formatters) {\n                this.applyFormatters(dataTable, formatters);\n                googleChartWrapper.setDataTable(dataTable);\n                googleChartWrapper.draw();\n            }\n            if (legendToggle === true || legend_toggle === true) {\n                this.grayOutHiddenColumns({\n                    options\n                });\n            }\n            return;\n        };\n        this.grayOutHiddenColumns = (param)=>{\n            let { options  } = param;\n            const { googleChartWrapper  } = this.props;\n            const dataTable = googleChartWrapper.getDataTable();\n            if (!dataTable) return;\n            const columnCount = dataTable.getNumberOfColumns();\n            const hasAHiddenColumn = this.state.hiddenColumns.length > 0;\n            if (hasAHiddenColumn === false) return;\n            const colors = Array.from({\n                length: columnCount - 1\n            }).map((dontcare, i)=>{\n                const columnID = this.getColumnID(dataTable, i + 1);\n                if (this.state.hiddenColumns.includes(columnID)) {\n                    return GRAY_COLOR;\n                } else if (options && options.colors) {\n                    return options.colors[i];\n                } else {\n                    return DEFAULT_CHART_COLORS[i];\n                }\n            });\n            googleChartWrapper.setOptions({\n                ...options,\n                colors\n            });\n            googleChartWrapper.draw();\n        };\n        this.onResize = ()=>{\n            const { googleChartWrapper  } = this.props;\n            googleChartWrapper.draw();\n        };\n    }\n}\nclass GoogleChartDataTable extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    componentDidMount() {}\n    componentWillUnmount() {}\n    shouldComponentUpdate() {\n        return false;\n    }\n    render() {\n        const { google , googleChartWrapper , googleChartDashboard  } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextConsumer, {\n            render: (props)=>{\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChartDataTableInner, Object.assign({}, props, {\n                    google: google,\n                    googleChartWrapper: googleChartWrapper,\n                    googleChartDashboard: googleChartDashboard\n                }));\n            }\n        });\n    }\n}\n\nclass GoogleChartEvents extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    shouldComponentUpdate() {\n        return false;\n    }\n    listenToEvents(param) {\n        let { chartEvents , google , googleChartWrapper  } = param;\n        if (!chartEvents) {\n            return;\n        }\n        google.visualization.events.removeAllListeners(googleChartWrapper);\n        for (let event of chartEvents){\n            var _this = this;\n            const { eventName , callback  } = event;\n            google.visualization.events.addListener(googleChartWrapper, eventName, function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                callback({\n                    chartWrapper: googleChartWrapper,\n                    props: _this.props,\n                    google: google,\n                    eventArgs: args\n                });\n            });\n        }\n    }\n    componentDidMount() {\n        var ref;\n        const { google , googleChartWrapper  } = this.props;\n        this.listenToEvents({\n            chartEvents: ((ref = this.propsFromContext) === null || ref === void 0 ? void 0 : ref.chartEvents) || null,\n            google,\n            googleChartWrapper\n        });\n    }\n    render() {\n        this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextConsumer, {\n            render: (propsFromContext)=>{\n                this.propsFromContext = propsFromContext;\n                return null;\n            }\n        });\n    }\n    constructor(props){\n        super(props);\n        this.propsFromContext = null;\n    }\n}\n\nlet controlCounter = 0;\nclass GoogleChart extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    componentDidMount() {\n        const { options , google , chartType , chartWrapperParams , toolbarItems , getChartEditor , getChartWrapper ,  } = this.props;\n        const chartConfig = {\n            chartType,\n            options,\n            containerId: this.getGraphID(),\n            ...chartWrapperParams\n        };\n        const googleChartWrapper = new google.visualization.ChartWrapper(chartConfig);\n        googleChartWrapper.setOptions(options || {});\n        if (getChartWrapper) {\n            getChartWrapper(googleChartWrapper, google);\n        }\n        const googleChartDashboard = new google.visualization.Dashboard(this.dashboard_ref);\n        const googleChartControls = this.addControls(googleChartWrapper, googleChartDashboard);\n        if (toolbarItems) {\n            google.visualization.drawToolbar(this.toolbar_ref.current, toolbarItems);\n        }\n        let googleChartEditor = null;\n        if (getChartEditor) {\n            googleChartEditor = new google.visualization.ChartEditor();\n            getChartEditor({\n                chartEditor: googleChartEditor,\n                chartWrapper: googleChartWrapper,\n                google\n            });\n        }\n        this.setState({\n            googleChartEditor,\n            googleChartControls: googleChartControls,\n            googleChartDashboard: googleChartDashboard,\n            googleChartWrapper,\n            isReady: true\n        });\n    }\n    componentDidUpdate() {\n        if (!this.state.googleChartWrapper) return;\n        if (!this.state.googleChartDashboard) return;\n        if (!this.state.googleChartControls) return;\n        const { controls  } = this.props;\n        if (controls) {\n            for(let i = 0; i < controls.length; i += 1){\n                const { controlType , options , controlWrapperParams  } = controls[i];\n                if (controlWrapperParams && \"state\" in controlWrapperParams) {\n                    this.state.googleChartControls[i].control.setState(controlWrapperParams[\"state\"]);\n                }\n                this.state.googleChartControls[i].control.setOptions(options);\n                this.state.googleChartControls[i].control.setControlType(controlType);\n            }\n        }\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n        return this.state.isReady !== nextState.isReady || nextProps.controls !== this.props.controls;\n    }\n    render() {\n        const { width , height , options , style  } = this.props;\n        const divStyle = {\n            height: height || options && options.height,\n            width: width || options && options.width,\n            ...style\n        };\n        if (this.props.render) {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                ref: this.dashboard_ref,\n                style: divStyle\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                ref: this.toolbar_ref,\n                id: \"toolbar\"\n            }), this.props.render({\n                renderChart: this.renderChart,\n                renderControl: this.renderControl,\n                renderToolbar: this.renderToolBar\n            }));\n        } else {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                ref: this.dashboard_ref,\n                style: divStyle\n            }, this.renderControl((param)=>{\n                let { controlProp  } = param;\n                return controlProp.controlPosition !== \"bottom\";\n            }), this.renderChart(), this.renderControl((param)=>{\n                let { controlProp  } = param;\n                return controlProp.controlPosition === \"bottom\";\n            }), this.renderToolBar());\n        }\n    }\n    constructor(...args1){\n        var _this1;\n        super(...args1), _this1 = this;\n        this.state = {\n            googleChartWrapper: null,\n            googleChartDashboard: null,\n            googleChartControls: null,\n            googleChartEditor: null,\n            isReady: false\n        };\n        this.graphID = null;\n        this.dashboard_ref = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.toolbar_ref = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.getGraphID = ()=>{\n            const { graphID , graph_id  } = this.props;\n            let instanceGraphID;\n            if (!graphID && !graph_id) {\n                if (!this.graphID) {\n                    instanceGraphID = generateUniqueID();\n                } else {\n                    instanceGraphID = this.graphID;\n                }\n            } else if (graphID && !graph_id) {\n                instanceGraphID = graphID;\n            } else if (graph_id && !graphID) {\n                instanceGraphID = graph_id;\n            } else {\n                instanceGraphID = graphID;\n            }\n            this.graphID = instanceGraphID;\n            return this.graphID;\n        };\n        this.getControlID = (id, index)=>{\n            controlCounter += 1;\n            let controlID;\n            if (typeof id === \"undefined\") {\n                controlID = \"googlechart-control-\".concat(index, \"-\").concat(controlCounter);\n            } else {\n                controlID = id;\n            }\n            return controlID;\n        };\n        this.addControls = (googleChartWrapper, googleChartDashboard)=>{\n            const { google , controls  } = this.props;\n            const googleChartControls = !controls ? null : controls.map((control, i)=>{\n                const { controlID: controlIDMaybe , controlType , options: controlOptions , controlWrapperParams ,  } = control;\n                const controlID = this.getControlID(controlIDMaybe, i);\n                return {\n                    controlProp: control,\n                    control: new google.visualization.ControlWrapper({\n                        containerId: controlID,\n                        controlType,\n                        options: controlOptions,\n                        ...controlWrapperParams\n                    })\n                };\n            });\n            if (!googleChartControls) {\n                return null;\n            }\n            googleChartDashboard.bind(googleChartControls.map((param)=>{\n                let { control  } = param;\n                return control;\n            }), googleChartWrapper);\n            for (let chartControl of googleChartControls){\n                const { control , controlProp  } = chartControl;\n                const { controlEvents =[]  } = controlProp;\n                for (let event of controlEvents){\n                    var _this = this;\n                    const { callback , eventName  } = event;\n                    google.visualization.events.removeListener(control, eventName, callback);\n                    google.visualization.events.addListener(control, eventName, function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        callback({\n                            chartWrapper: googleChartWrapper,\n                            controlWrapper: control,\n                            props: _this.props,\n                            google: google,\n                            eventArgs: args\n                        });\n                    });\n                }\n            }\n            return googleChartControls;\n        };\n        this.renderChart = ()=>{\n            const { width , height , options , style , className , rootProps , google  } = this.props;\n            const divStyle = {\n                height: height || options && options.height,\n                width: width || options && options.width,\n                ...style\n            };\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", Object.assign({\n                id: this.getGraphID(),\n                style: divStyle,\n                className: className\n            }, rootProps), this.state.isReady && this.state.googleChartWrapper !== null ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChartDataTable, {\n                googleChartWrapper: this.state.googleChartWrapper,\n                google: google,\n                googleChartDashboard: this.state.googleChartDashboard\n            }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChartEvents, {\n                googleChartWrapper: this.state.googleChartWrapper,\n                google: google\n            })) : null);\n        };\n        this.renderControl = function() {\n            let filter = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (param)=>{\n                return true;\n            };\n            return _this1.state.isReady && _this1.state.googleChartControls !== null ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, _this1.state.googleChartControls.filter((param)=>{\n                let { controlProp , control  } = param;\n                return filter({\n                    control,\n                    controlProp\n                });\n            }).map((param)=>{\n                let { control , controlProp  } = param;\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                    key: control.getContainerId(),\n                    id: control.getContainerId()\n                });\n            })) : null;\n        };\n        this.renderToolBar = ()=>{\n            if (!this.props.toolbarItems) return null;\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n                ref: this.toolbar_ref\n            });\n        };\n    }\n}\n\nclass Chart$1 extends (react__WEBPACK_IMPORTED_MODULE_0__.Component) {\n    render() {\n        const { chartLanguage , chartPackages , chartVersion , mapsApiKey , loader , errorElement ,  } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextProvider, {\n            value: this.props\n        }, this.state.loadingStatus === \"ready\" && this.state.google !== null ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleChart, Object.assign({}, this.props, {\n            google: this.state.google\n        })) : this.state.loadingStatus === \"errored\" && errorElement ? errorElement : loader, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LoadGoogleCharts, {\n            chartLanguage: chartLanguage,\n            chartPackages: chartPackages,\n            chartVersion: chartVersion,\n            mapsApiKey: mapsApiKey,\n            onLoad: this.onLoad,\n            onError: this.onError\n        }));\n    }\n    componentDidMount() {\n        this._isMounted = true;\n    }\n    componentWillUnmount() {\n        this._isMounted = false;\n    }\n    isFullyLoaded(google) {\n        const { controls , toolbarItems , getChartEditor  } = this.props;\n        return google && google.visualization && google.visualization.ChartWrapper && google.visualization.Dashboard && (!controls || google.visualization.ChartWrapper) && (!getChartEditor || google.visualization.ChartEditor) && (!toolbarItems || google.visualization.drawToolbar);\n    }\n    constructor(...args){\n        super(...args);\n        this._isMounted = false;\n        this.state = {\n            loadingStatus: \"loading\",\n            google: null\n        };\n        this.onLoad = (google1)=>{\n            if (this.props.onLoad) {\n                this.props.onLoad(google1);\n            }\n            if (this.isFullyLoaded(google1)) {\n                this.onSuccess(google1);\n            } else {\n                // IE11: window.google is not fully set, we have to wait\n                const id = setInterval(()=>{\n                    const google = window.google;\n                    if (this._isMounted) {\n                        if (google && this.isFullyLoaded(google)) {\n                            clearInterval(id);\n                            this.onSuccess(google);\n                        }\n                    } else {\n                        clearInterval(id);\n                    }\n                }, 1000);\n            }\n        };\n        this.onSuccess = (google)=>{\n            this.setState({\n                loadingStatus: \"ready\",\n                google\n            });\n        };\n        this.onError = ()=>{\n            this.setState({\n                loadingStatus: \"errored\"\n            });\n        };\n    }\n}\nChart$1.defaultProps = chartDefaultProps;\n\nvar GoogleDataTableColumnRoleType;\n(function(GoogleDataTableColumnRoleType) {\n    GoogleDataTableColumnRoleType[\"annotation\"] = \"annotation\";\n    GoogleDataTableColumnRoleType[\"annotationText\"] = \"annotationText\";\n    GoogleDataTableColumnRoleType[\"certainty\"] = \"certainty\";\n    GoogleDataTableColumnRoleType[\"emphasis\"] = \"emphasis\";\n    GoogleDataTableColumnRoleType[\"interval\"] = \"interval\";\n    GoogleDataTableColumnRoleType[\"scope\"] = \"scope\";\n    GoogleDataTableColumnRoleType[\"style\"] = \"style\";\n    GoogleDataTableColumnRoleType[\"tooltip\"] = \"tooltip\";\n    GoogleDataTableColumnRoleType[\"domain\"] = \"domain\";\n})(GoogleDataTableColumnRoleType || (GoogleDataTableColumnRoleType = {}));\n\nvar Chart = Chart$1;\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ29vZ2xlLWNoYXJ0cy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDYTs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDLCtDQUFRO0FBQ3BELGdDQUFnQywrQ0FBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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XGhhc3NhXFxEZXNrdG9wXFxDdXJyZW50bHkgUnVubmluZyBDYW1wYWlnbiBQcm9qZWN0IEJhY2tlbmVkIGFuZCBmcm9udGVuZWRcXERhc2hib2FyZC1tYWluXFxEYXNoYm9hcmQtbWFpblxcbm9kZV9tb2R1bGVzXFxyZWFjdC1nb29nbGUtY2hhcnRzXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEhvb2sgdG8gbG9hZCBleHRlcm5hbCBzY3JpcHQuXG4gKiBAcGFyYW0gc3JjIC0gU291cmNlIHVybCB0byBsb2FkLlxuICogQHBhcmFtIG9uTG9hZCAtIFN1Y2Nlc3MgY2FsbGJhY2suXG4gKiBAcGFyYW0gb25FcnJvciAtIEVycm9yIGNhbGxiYWNrLlxuICovIGZ1bmN0aW9uIHVzZUxvYWRTY3JpcHQoc3JjLCBvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgc2NyaXB0IHRhZyB3aXRoIHNhbWUgc3JjIGluIERPTS5cbiAgICAgICAgY29uc3QgZm91bmRTY3JpcHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbc3JjPVwiJy5jb25jYXQoc3JjLCAnXCJdJykpO1xuICAgICAgICAvLyBDYWxsIG9uTG9hZCBpZiBzY3JpcHQgbWFya2VkIGFzIGxvYWRlZC5cbiAgICAgICAgaWYgKGZvdW5kU2NyaXB0ID09PSBudWxsIHx8IGZvdW5kU2NyaXB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3VuZFNjcmlwdC5kYXRhc2V0LmxvYWRlZCkge1xuICAgICAgICAgICAgb25Mb2FkID09PSBudWxsIHx8IG9uTG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Mb2FkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIG9yIGdldCBleGlzdGVkIHRhZy5cbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gZm91bmRTY3JpcHQgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgLy8gU2V0IHNyYyBpZiBubyBzY3JpcHQgd2FzIGZvdW5kLlxuICAgICAgICBpZiAoIWZvdW5kU2NyaXB0KSB7XG4gICAgICAgICAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgc2NyaXB0IGFzIGxvYWRlZCBvbiBsb2FkIGV2ZW50LlxuICAgICAgICBjb25zdCBvbkxvYWRXaXRoTWFya2VyID0gKCk9PntcbiAgICAgICAgICAgIHNjcmlwdC5kYXRhc2V0LmxvYWRlZCA9IFwiMVwiO1xuICAgICAgICAgICAgb25Mb2FkID09PSBudWxsIHx8IG9uTG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25Mb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWRXaXRoTWFya2VyKTtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRvIERPTSBpZiBub3QgeWV0IGFkZGVkLlxuICAgICAgICBpZiAoIWZvdW5kU2NyaXB0KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZChzY3JpcHQpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xufVxuXG4vKipcbiAqIEhvb2sgdG8gbG9hZCBHb29nbGUgQ2hhcnRzIEpTIEFQSS5cbiAqIEBwYXJhbSBwYXJhbXMgLSBMb2FkIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0gW3BhcmFtcy5jaGFydFZlcnNpb25dIC0gQ2hhcnQgdmVyc2lvbiB0byBsb2FkLlxuICogQHBhcmFtIFtwYXJhbXMuY2hhcnRQYWNrYWdlc10gLSBQYWNrYWdlcyB0byBsb2FkLlxuICogQHBhcmFtIFtwYXJhbXMuY2hhcnRMYW5ndWFnZV0gLSBMYW5ndWFnZXMgdG8gbG9hZC5cbiAqIEBwYXJhbSBbcGFyYW1zLm1hcHNBcGlLZXldIC0gR29vZ2xlIE1hcHMgYXBpIGtleS5cbiAqIEByZXR1cm5zXG4gKi8gZnVuY3Rpb24gdXNlTG9hZEdvb2dsZUNoYXJ0cyhwYXJhbSkge1xuICAgIGxldCB7IGNoYXJ0VmVyc2lvbiA9XCJjdXJyZW50XCIgLCBjaGFydFBhY2thZ2VzID1bXG4gICAgICAgIFwiY29yZWNoYXJ0XCIsXG4gICAgICAgIFwiY29udHJvbHNcIlxuICAgIF0gLCBjaGFydExhbmd1YWdlID1cImVuXCIgLCBtYXBzQXBpS2V5ICB9ID0gcGFyYW07XG4gICAgY29uc3QgW2dvb2dsZUNoYXJ0cywgc2V0R29vZ2xlQ2hhcnRzXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtmYWlsZWQsIHNldEZhaWxlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgdXNlTG9hZFNjcmlwdChcImh0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2NoYXJ0cy9sb2FkZXIuanNcIiwgKCk9PntcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBHZXR0aW5nIG9iamVjdCBmcm9tIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICAgIGNvbnN0IGdvb2dsZSA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5nb29nbGU7XG4gICAgICAgIGlmICghZ29vZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZ29vZ2xlLmNoYXJ0cy5sb2FkKGNoYXJ0VmVyc2lvbiwge1xuICAgICAgICAgICAgcGFja2FnZXM6IGNoYXJ0UGFja2FnZXMsXG4gICAgICAgICAgICBsYW5ndWFnZTogY2hhcnRMYW5ndWFnZSxcbiAgICAgICAgICAgIG1hcHNBcGlLZXlcbiAgICAgICAgfSk7XG4gICAgICAgIGdvb2dsZS5jaGFydHMuc2V0T25Mb2FkQ2FsbGJhY2soKCk9PntcbiAgICAgICAgICAgIHNldEdvb2dsZUNoYXJ0cyhnb29nbGUpO1xuICAgICAgICB9KTtcbiAgICB9LCAoKT0+e1xuICAgICAgICBzZXRGYWlsZWQodHJ1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZ29vZ2xlQ2hhcnRzLFxuICAgICAgICBmYWlsZWRcbiAgICBdO1xufVxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCB1c2VMb2FkR29vZ2xlQ2hhcnRzIHRvIHVzZSBpbiBsZWdhY3kgY29tcG9uZW50cy5cbiAqLyBmdW5jdGlvbiBMb2FkR29vZ2xlQ2hhcnRzKHBhcmFtKSB7XG4gICAgbGV0IHsgb25Mb2FkICwgb25FcnJvciAsIC4uLnBhcmFtcyB9ID0gcGFyYW07XG4gICAgY29uc3QgW2dvb2dsZUNoYXJ0cywgZmFpbGVkXSA9IHVzZUxvYWRHb29nbGVDaGFydHMocGFyYW1zKTtcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGdvb2dsZUNoYXJ0cyAmJiBvbkxvYWQpIHtcbiAgICAgICAgICAgIG9uTG9hZChnb29nbGVDaGFydHMpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBnb29nbGVDaGFydHNcbiAgICBdKTtcbiAgICB1c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGZhaWxlZCAmJiBvbkVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGZhaWxlZFxuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBjaGFydERlZmF1bHRQcm9wcyA9IHtcbiAgICAvLyA8REVQUkVDQVRFRF9QUk9QUz5cbiAgICBsZWdlbmRfdG9nZ2xlOiBmYWxzZSxcbiAgICAvLyA8L0RFUFJFQ0FURURfUFJPUFM+XG4gICAgb3B0aW9uczoge30sXG4gICAgbGVnZW5kVG9nZ2xlOiBmYWxzZSxcbiAgICBnZXRDaGFydFdyYXBwZXI6ICgpPT57fSxcbiAgICBzcHJlYWRTaGVldFF1ZXJ5UGFyYW1ldGVyczoge1xuICAgICAgICBoZWFkZXJzOiAxLFxuICAgICAgICBnaWQ6IDFcbiAgICB9LFxuICAgIHJvb3RQcm9wczoge30sXG4gICAgY2hhcnRXcmFwcGVyUGFyYW1zOiB7fVxufTtcblxubGV0IHVuaXF1ZUlEID0gMDtcbmNvbnN0IGdlbmVyYXRlVW5pcXVlSUQgPSAoKT0+e1xuICAgIHVuaXF1ZUlEICs9IDE7XG4gICAgcmV0dXJuIFwicmVhY3Rnb29nbGVncmFwaC1cIi5jb25jYXQodW5pcXVlSUQpO1xufTtcblxuY29uc3QgREVGQVVMVF9DSEFSVF9DT0xPUlMgPSBbXG4gICAgXCIjMzM2NkNDXCIsXG4gICAgXCIjREMzOTEyXCIsXG4gICAgXCIjRkY5OTAwXCIsXG4gICAgXCIjMTA5NjE4XCIsXG4gICAgXCIjOTkwMDk5XCIsXG4gICAgXCIjM0IzRUFDXCIsXG4gICAgXCIjMDA5OUM2XCIsXG4gICAgXCIjREQ0NDc3XCIsXG4gICAgXCIjNjZBQTAwXCIsXG4gICAgXCIjQjgyRTJFXCIsXG4gICAgXCIjMzE2Mzk1XCIsXG4gICAgXCIjOTk0NDk5XCIsXG4gICAgXCIjMjJBQTk5XCIsXG4gICAgXCIjQUFBQTExXCIsXG4gICAgXCIjNjYzM0NDXCIsXG4gICAgXCIjRTY3MzAwXCIsXG4gICAgXCIjOEIwNzA3XCIsXG4gICAgXCIjMzI5MjYyXCIsXG4gICAgXCIjNTU3NEE2XCIsXG4gICAgXCIjM0IzRUFDXCJcbl07XG5cbmNvbnN0IGxvYWREYXRhVGFibGVGcm9tU3ByZWFkU2hlZXQgPSBhc3luYyBmdW5jdGlvbihnb29nbGVWaXosIHNwcmVhZFNoZWV0VXJsKSB7XG4gICAgbGV0IHVybFBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBcIlwiLmNvbmNhdCh1cmxQYXJhbXMuaGVhZGVycyA/IFwiaGVhZGVycz1cIi5jb25jYXQodXJsUGFyYW1zLmhlYWRlcnMpIDogXCJoZWFkZXJzPTBcIik7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gXCJcIi5jb25jYXQodXJsUGFyYW1zLnF1ZXJ5ID8gXCImdHE9XCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudCh1cmxQYXJhbXMucXVlcnkpKSA6IFwiXCIpO1xuICAgICAgICBjb25zdCBnaWQgPSBcIlwiLmNvbmNhdCh1cmxQYXJhbXMuZ2lkID8gXCImZ2lkPVwiLmNvbmNhdCh1cmxQYXJhbXMuZ2lkKSA6IFwiXCIpO1xuICAgICAgICBjb25zdCBzaGVldCA9IFwiXCIuY29uY2F0KHVybFBhcmFtcy5zaGVldCA/IFwiJnNoZWV0PVwiLmNvbmNhdCh1cmxQYXJhbXMuc2hlZXQpIDogXCJcIik7XG4gICAgICAgIGNvbnN0IGFjY2Vzc190b2tlbiA9IFwiXCIuY29uY2F0KHVybFBhcmFtcy5hY2Nlc3NfdG9rZW4gPyBcIiZhY2Nlc3NfdG9rZW49XCIuY29uY2F0KHVybFBhcmFtcy5hY2Nlc3NfdG9rZW4pIDogXCJcIik7XG4gICAgICAgIGNvbnN0IHVybFF1ZXJ5U3RyaW5nID0gXCJcIi5jb25jYXQoaGVhZGVycykuY29uY2F0KGdpZCkuY29uY2F0KHNoZWV0KS5jb25jYXQocXVlcnlTdHJpbmcpLmNvbmNhdChhY2Nlc3NfdG9rZW4pO1xuICAgICAgICBjb25zdCB1cmxUb1NwcmVhZFNoZWV0ID0gXCJcIi5jb25jYXQoc3ByZWFkU2hlZXRVcmwsIFwiL2d2aXovdHE/XCIpLmNvbmNhdCh1cmxRdWVyeVN0cmluZyk7IC8vJnRxPSR7cXVlcnlTdHJpbmd9YDtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgZ29vZ2xlVml6LnZpc3VhbGl6YXRpb24uUXVlcnkodXJsVG9TcHJlYWRTaGVldCk7XG4gICAgICAgIHF1ZXJ5LnNlbmQoKHJlc3BvbnNlKT0+e1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmlzRXJyb3IoKSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChcIkVycm9yIGluIHF1ZXJ5OiAgXCIuY29uY2F0KHJlc3BvbnNlLmdldE1lc3NhZ2UoKSwgXCIgXCIpLmNvbmNhdChyZXNwb25zZS5nZXREZXRhaWxlZE1lc3NhZ2UoKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLmdldERhdGFUYWJsZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCB7IFByb3ZpZGVyICwgQ29uc3VtZXIgIH0gPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQoY2hhcnREZWZhdWx0UHJvcHMpO1xuY29uc3QgQ29udGV4dFByb3ZpZGVyID0gKHBhcmFtKT0+e1xuICAgIGxldCB7IGNoaWxkcmVuICwgdmFsdWUgIH0gPSBwYXJhbTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBDb250ZXh0Q29uc3VtZXIgPSAocGFyYW0pPT57XG4gICAgbGV0IHsgcmVuZGVyICB9ID0gcGFyYW07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25zdW1lciwgbnVsbCwgKGNvbnRleHQpPT57XG4gICAgICAgIHJldHVybiByZW5kZXIoY29udGV4dCk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBHUkFZX0NPTE9SID0gXCIjQ0NDQ0NDXCI7XG5jbGFzcyBHb29nbGVDaGFydERhdGFUYWJsZUlubmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5kcmF3KHRoaXMucHJvcHMpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMubGVnZW5kX3RvZ2dsZSB8fCB0aGlzLnByb3BzLmxlZ2VuZFRvZ2dsZSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5Ub0xlZ2VuZFRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBjb25zdCB7IGdvb2dsZSAsIGdvb2dsZUNoYXJ0V3JhcHBlciAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKGdvb2dsZUNoYXJ0V3JhcHBlcik7XG4gICAgICAgIGlmIChnb29nbGVDaGFydFdyYXBwZXIuZ2V0Q2hhcnRUeXBlKCkgPT09IFwiVGltZWxpbmVcIikge1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldENoYXJ0KCkgJiYgZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldENoYXJ0KCkuY2xlYXJDaGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5kcmF3KHRoaXMucHJvcHMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBoaWRkZW5Db2x1bW5zOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RlblRvTGVnZW5kVG9nZ2xlID0gKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgZ29vZ2xlICwgZ29vZ2xlQ2hhcnRXcmFwcGVyICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGdvb2dsZS52aXN1YWxpemF0aW9uLmV2ZW50cy5hZGRMaXN0ZW5lcihnb29nbGVDaGFydFdyYXBwZXIsIFwic2VsZWN0XCIsICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhcnQgPSBnb29nbGVDaGFydFdyYXBwZXIuZ2V0Q2hhcnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBjaGFydC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVGFibGUgPSBnb29nbGVDaGFydFdyYXBwZXIuZ2V0RGF0YVRhYmxlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggPT09IDAgfHwgLy8gV2Ugd2FudCB0byBsaXN0ZW4gdG8gd2hlbiBhIHdob2xlIHJvdyBpcyBzZWxlY3RlZC4gVGhpcyBpcyB0aGUgY2FzZSBvbmx5IHdoZW4gcm93ID09PSBudWxsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uWzBdLnJvdyB8fCAhZGF0YVRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uSW5kZXggPSBzZWxlY3Rpb25bMF0uY29sdW1uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbklEID0gdGhpcy5nZXRDb2x1bW5JRChkYXRhVGFibGUsIGNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5oaWRkZW5Db2x1bW5zLmluY2x1ZGVzKGNvbHVtbklEKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKChzdGF0ZSk9Pih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuQ29sdW1uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0ZS5oaWRkZW5Db2x1bW5zLmZpbHRlcigoY29sSUQpPT5jb2xJRCAhPT0gY29sdW1uSUQpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgoc3RhdGUpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbkNvbHVtbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdGUuaGlkZGVuQ29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXBwbHlGb3JtYXR0ZXJzID0gKGRhdGFUYWJsZSwgZm9ybWF0dGVycyk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgZ29vZ2xlICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGZvciAobGV0IGZvcm1hdHRlciBvZiBmb3JtYXR0ZXJzKXtcbiAgICAgICAgICAgICAgICBzd2l0Y2goZm9ybWF0dGVyLnR5cGUpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dGb3JtYXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXpGb3JtYXR0ZXIgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uQXJyb3dGb3JtYXQoZm9ybWF0dGVyLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpekZvcm1hdHRlci5mb3JtYXQoZGF0YVRhYmxlLCBmb3JtYXR0ZXIuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkJhckZvcm1hdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpekZvcm1hdHRlciA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5CYXJGb3JtYXQoZm9ybWF0dGVyLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpekZvcm1hdHRlci5mb3JtYXQoZGF0YVRhYmxlLCBmb3JtYXR0ZXIuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkNvbG9yRm9ybWF0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdml6Rm9ybWF0dGVyID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkNvbG9yRm9ybWF0KGZvcm1hdHRlci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJhbmdlcyAgfSA9IGZvcm1hdHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByYW5nZSBvZiByYW5nZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXpGb3JtYXR0ZXIuYWRkUmFuZ2UoLi4ucmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXpGb3JtYXR0ZXIuZm9ybWF0KGRhdGFUYWJsZSwgZm9ybWF0dGVyLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEYXRlRm9ybWF0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgdml6Rm9ybWF0dGVyID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhdGVGb3JtYXQoZm9ybWF0dGVyLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpekZvcm1hdHRlci5mb3JtYXQoZGF0YVRhYmxlLCBmb3JtYXR0ZXIuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk51bWJlckZvcm1hdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpekZvcm1hdHRlciA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5OdW1iZXJGb3JtYXQoZm9ybWF0dGVyLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpekZvcm1hdHRlci5mb3JtYXQoZGF0YVRhYmxlLCBmb3JtYXR0ZXIuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlBhdHRlcm5Gb3JtYXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2aXpGb3JtYXR0ZXIgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uUGF0dGVybkZvcm1hdChmb3JtYXR0ZXIub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdml6Rm9ybWF0dGVyLmZvcm1hdChkYXRhVGFibGUsIGZvcm1hdHRlci5jb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDb2x1bW5JRCA9IChkYXRhVGFibGUsIGNvbHVtbkluZGV4KT0+e1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFUYWJsZS5nZXRDb2x1bW5JZChjb2x1bW5JbmRleCkgfHwgZGF0YVRhYmxlLmdldENvbHVtbkxhYmVsKGNvbHVtbkluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcmF3ID0gYXN5bmMgKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgZGF0YSAsIGRpZmZkYXRhICwgcm93cyAsIGNvbHVtbnMgLCBvcHRpb25zICwgbGVnZW5kX3RvZ2dsZSAsIGxlZ2VuZFRvZ2dsZSAsIGNoYXJ0VHlwZSAsIGZvcm1hdHRlcnMgLCBzcHJlYWRTaGVldFVybCAsIHNwcmVhZFNoZWV0UXVlcnlQYXJhbWV0ZXJzICB9ID0gcGFyYW07XG4gICAgICAgICAgICBjb25zdCB7IGdvb2dsZSAsIGdvb2dsZUNoYXJ0V3JhcHBlciAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBsZXQgZGF0YVRhYmxlO1xuICAgICAgICAgICAgbGV0IGNoYXJ0RGlmZiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZGlmZmRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGREYXRhID0gZ29vZ2xlLnZpc3VhbGl6YXRpb24uYXJyYXlUb0RhdGFUYWJsZShkaWZmZGF0YS5vbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSBnb29nbGUudmlzdWFsaXphdGlvbi5hcnJheVRvRGF0YVRhYmxlKGRpZmZkYXRhLm5ldyk7XG4gICAgICAgICAgICAgICAgY2hhcnREaWZmID0gZ29vZ2xlLnZpc3VhbGl6YXRpb25bY2hhcnRUeXBlXS5wcm90b3R5cGUuY29tcHV0ZURpZmYob2xkRGF0YSwgbmV3RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUYWJsZSA9IGdvb2dsZS52aXN1YWxpemF0aW9uLmFycmF5VG9EYXRhVGFibGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRhYmxlID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhdGFUYWJsZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJvd3MgJiYgY29sdW1ucykge1xuICAgICAgICAgICAgICAgIGRhdGFUYWJsZSA9IGdvb2dsZS52aXN1YWxpemF0aW9uLmFycmF5VG9EYXRhVGFibGUoW1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgICAgICAgICAuLi5yb3dzXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNwcmVhZFNoZWV0VXJsKSB7XG4gICAgICAgICAgICAgICAgZGF0YVRhYmxlID0gYXdhaXQgbG9hZERhdGFUYWJsZUZyb21TcHJlYWRTaGVldChnb29nbGUsIHNwcmVhZFNoZWV0VXJsLCBzcHJlYWRTaGVldFF1ZXJ5UGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFUYWJsZSA9IGdvb2dsZS52aXN1YWxpemF0aW9uLmFycmF5VG9EYXRhVGFibGUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29sdW1uQ291bnQgPSBkYXRhVGFibGUuZ2V0TnVtYmVyT2ZDb2x1bW5zKCk7XG4gICAgICAgICAgICBjb25zdCB2aWV3Q29sdW1ucyA9IEFycmF5KGNvbHVtbkNvdW50KS5maWxsKDApLm1hcCgoYywgaSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5JRCA9IHRoaXMuZ2V0Q29sdW1uSUQoZGF0YVRhYmxlLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5oaWRkZW5Db2x1bW5zLmluY2x1ZGVzKGNvbHVtbklEKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGRhdGFUYWJsZS5nZXRDb2x1bW5MYWJlbChpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGRhdGFUYWJsZS5nZXRDb2x1bW5UeXBlKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsYzogKCk9Pm51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJ0ID0gZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldENoYXJ0KCk7XG4gICAgICAgICAgICBpZiAoZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldENoYXJ0VHlwZSgpID09PSBcIlRpbWVsaW5lXCIpIHtcbiAgICAgICAgICAgICAgICBjaGFydCAmJiBjaGFydC5jbGVhckNoYXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuc2V0Q2hhcnRUeXBlKGNoYXJ0VHlwZSk7XG4gICAgICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuc2V0T3B0aW9ucyhvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdUYWJsZSA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVmlldyhkYXRhVGFibGUpO1xuICAgICAgICAgICAgdmlld1RhYmxlLnNldENvbHVtbnModmlld0NvbHVtbnMpO1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLnNldERhdGFUYWJsZSh2aWV3VGFibGUpO1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLmRyYXcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmdvb2dsZUNoYXJ0RGFzaGJvYXJkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5nb29nbGVDaGFydERhc2hib2FyZC5kcmF3KGRhdGFUYWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhcnREaWZmKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLnNldERhdGFUYWJsZShjaGFydERpZmYpO1xuICAgICAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0dGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlGb3JtYXR0ZXJzKGRhdGFUYWJsZSwgZm9ybWF0dGVycyk7XG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLnNldERhdGFUYWJsZShkYXRhVGFibGUpO1xuICAgICAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlci5kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVnZW5kVG9nZ2xlID09PSB0cnVlIHx8IGxlZ2VuZF90b2dnbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXlPdXRIaWRkZW5Db2x1bW5zKHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdyYXlPdXRIaWRkZW5Db2x1bW5zID0gKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgY29uc3QgeyBnb29nbGVDaGFydFdyYXBwZXIgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgZGF0YVRhYmxlID0gZ29vZ2xlQ2hhcnRXcmFwcGVyLmdldERhdGFUYWJsZSgpO1xuICAgICAgICAgICAgaWYgKCFkYXRhVGFibGUpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gZGF0YVRhYmxlLmdldE51bWJlck9mQ29sdW1ucygpO1xuICAgICAgICAgICAgY29uc3QgaGFzQUhpZGRlbkNvbHVtbiA9IHRoaXMuc3RhdGUuaGlkZGVuQ29sdW1ucy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgaWYgKGhhc0FIaWRkZW5Db2x1bW4gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBjb2xvcnMgPSBBcnJheS5mcm9tKHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGNvbHVtbkNvdW50IC0gMVxuICAgICAgICAgICAgfSkubWFwKChkb250Y2FyZSwgaSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5JRCA9IHRoaXMuZ2V0Q29sdW1uSUQoZGF0YVRhYmxlLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaGlkZGVuQ29sdW1ucy5pbmNsdWRlcyhjb2x1bW5JRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEdSQVlfQ09MT1I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29sb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbG9yc1tpXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gREVGQVVMVF9DSEFSVF9DT0xPUlNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjb2xvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLmRyYXcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSA9ICgpPT57XG4gICAgICAgICAgICBjb25zdCB7IGdvb2dsZUNoYXJ0V3JhcHBlciAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBnb29nbGVDaGFydFdyYXBwZXIuZHJhdygpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIEdvb2dsZUNoYXJ0RGF0YVRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHt9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7fVxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgZ29vZ2xlICwgZ29vZ2xlQ2hhcnRXcmFwcGVyICwgZ29vZ2xlQ2hhcnREYXNoYm9hcmQgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRDb25zdW1lciwge1xuICAgICAgICAgICAgcmVuZGVyOiAocHJvcHMpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChHb29nbGVDaGFydERhdGFUYWJsZUlubmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGU6IGdvb2dsZSxcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyOiBnb29nbGVDaGFydFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZUNoYXJ0RGFzaGJvYXJkOiBnb29nbGVDaGFydERhc2hib2FyZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBHb29nbGVDaGFydEV2ZW50cyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxpc3RlblRvRXZlbnRzKHBhcmFtKSB7XG4gICAgICAgIGxldCB7IGNoYXJ0RXZlbnRzICwgZ29vZ2xlICwgZ29vZ2xlQ2hhcnRXcmFwcGVyICB9ID0gcGFyYW07XG4gICAgICAgIGlmICghY2hhcnRFdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKGdvb2dsZUNoYXJ0V3JhcHBlcik7XG4gICAgICAgIGZvciAobGV0IGV2ZW50IG9mIGNoYXJ0RXZlbnRzKXtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50TmFtZSAsIGNhbGxiYWNrICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMuYWRkTGlzdGVuZXIoZ29vZ2xlQ2hhcnRXcmFwcGVyLCBldmVudE5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBjaGFydFdyYXBwZXI6IGdvb2dsZUNoYXJ0V3JhcHBlcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgICAgICBnb29nbGU6IGdvb2dsZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRBcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgY29uc3QgeyBnb29nbGUgLCBnb29nbGVDaGFydFdyYXBwZXIgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLmxpc3RlblRvRXZlbnRzKHtcbiAgICAgICAgICAgIGNoYXJ0RXZlbnRzOiAoKHJlZiA9IHRoaXMucHJvcHNGcm9tQ29udGV4dCkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuY2hhcnRFdmVudHMpIHx8IG51bGwsXG4gICAgICAgICAgICBnb29nbGUsXG4gICAgICAgICAgICBnb29nbGVDaGFydFdyYXBwZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0Q29uc3VtZXIsIHtcbiAgICAgICAgICAgIHJlbmRlcjogKHByb3BzRnJvbUNvbnRleHQpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wc0Zyb21Db250ZXh0ID0gcHJvcHNGcm9tQ29udGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnByb3BzRnJvbUNvbnRleHQgPSBudWxsO1xuICAgIH1cbn1cblxubGV0IGNvbnRyb2xDb3VudGVyID0gMDtcbmNsYXNzIEdvb2dsZUNoYXJ0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zICwgZ29vZ2xlICwgY2hhcnRUeXBlICwgY2hhcnRXcmFwcGVyUGFyYW1zICwgdG9vbGJhckl0ZW1zICwgZ2V0Q2hhcnRFZGl0b3IgLCBnZXRDaGFydFdyYXBwZXIgLCAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGNoYXJ0Q29uZmlnID0ge1xuICAgICAgICAgICAgY2hhcnRUeXBlLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGNvbnRhaW5lcklkOiB0aGlzLmdldEdyYXBoSUQoKSxcbiAgICAgICAgICAgIC4uLmNoYXJ0V3JhcHBlclBhcmFtc1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnb29nbGVDaGFydFdyYXBwZXIgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyKGNoYXJ0Q29uZmlnKTtcbiAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLnNldE9wdGlvbnMob3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGlmIChnZXRDaGFydFdyYXBwZXIpIHtcbiAgICAgICAgICAgIGdldENoYXJ0V3JhcHBlcihnb29nbGVDaGFydFdyYXBwZXIsIGdvb2dsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ29vZ2xlQ2hhcnREYXNoYm9hcmQgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGFzaGJvYXJkKHRoaXMuZGFzaGJvYXJkX3JlZik7XG4gICAgICAgIGNvbnN0IGdvb2dsZUNoYXJ0Q29udHJvbHMgPSB0aGlzLmFkZENvbnRyb2xzKGdvb2dsZUNoYXJ0V3JhcHBlciwgZ29vZ2xlQ2hhcnREYXNoYm9hcmQpO1xuICAgICAgICBpZiAodG9vbGJhckl0ZW1zKSB7XG4gICAgICAgICAgICBnb29nbGUudmlzdWFsaXphdGlvbi5kcmF3VG9vbGJhcih0aGlzLnRvb2xiYXJfcmVmLmN1cnJlbnQsIHRvb2xiYXJJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdvb2dsZUNoYXJ0RWRpdG9yID0gbnVsbDtcbiAgICAgICAgaWYgKGdldENoYXJ0RWRpdG9yKSB7XG4gICAgICAgICAgICBnb29nbGVDaGFydEVkaXRvciA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydEVkaXRvcigpO1xuICAgICAgICAgICAgZ2V0Q2hhcnRFZGl0b3Ioe1xuICAgICAgICAgICAgICAgIGNoYXJ0RWRpdG9yOiBnb29nbGVDaGFydEVkaXRvcixcbiAgICAgICAgICAgICAgICBjaGFydFdyYXBwZXI6IGdvb2dsZUNoYXJ0V3JhcHBlcixcbiAgICAgICAgICAgICAgICBnb29nbGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRFZGl0b3IsXG4gICAgICAgICAgICBnb29nbGVDaGFydENvbnRyb2xzOiBnb29nbGVDaGFydENvbnRyb2xzLFxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnREYXNoYm9hcmQ6IGdvb2dsZUNoYXJ0RGFzaGJvYXJkLFxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyLFxuICAgICAgICAgICAgaXNSZWFkeTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZ29vZ2xlQ2hhcnRXcmFwcGVyKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5nb29nbGVDaGFydERhc2hib2FyZCkgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZ29vZ2xlQ2hhcnRDb250cm9scykgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGNvbnRyb2xzICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKGNvbnRyb2xzKSB7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgY29udHJvbHMubGVuZ3RoOyBpICs9IDEpe1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29udHJvbFR5cGUgLCBvcHRpb25zICwgY29udHJvbFdyYXBwZXJQYXJhbXMgIH0gPSBjb250cm9sc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbFdyYXBwZXJQYXJhbXMgJiYgXCJzdGF0ZVwiIGluIGNvbnRyb2xXcmFwcGVyUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ29vZ2xlQ2hhcnRDb250cm9sc1tpXS5jb250cm9sLnNldFN0YXRlKGNvbnRyb2xXcmFwcGVyUGFyYW1zW1wic3RhdGVcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdvb2dsZUNoYXJ0Q29udHJvbHNbaV0uY29udHJvbC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ29vZ2xlQ2hhcnRDb250cm9sc1tpXS5jb250cm9sLnNldENvbnRyb2xUeXBlKGNvbnRyb2xUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNSZWFkeSAhPT0gbmV4dFN0YXRlLmlzUmVhZHkgfHwgbmV4dFByb3BzLmNvbnRyb2xzICE9PSB0aGlzLnByb3BzLmNvbnRyb2xzO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGggLCBoZWlnaHQgLCBvcHRpb25zICwgc3R5bGUgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBkaXZTdHlsZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggfHwgb3B0aW9ucyAmJiBvcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgLi4uc3R5bGVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHRoaXMuZGFzaGJvYXJkX3JlZixcbiAgICAgICAgICAgICAgICBzdHlsZTogZGl2U3R5bGVcbiAgICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiB0aGlzLnRvb2xiYXJfcmVmLFxuICAgICAgICAgICAgICAgIGlkOiBcInRvb2xiYXJcIlxuICAgICAgICAgICAgfSksIHRoaXMucHJvcHMucmVuZGVyKHtcbiAgICAgICAgICAgICAgICByZW5kZXJDaGFydDogdGhpcy5yZW5kZXJDaGFydCxcbiAgICAgICAgICAgICAgICByZW5kZXJDb250cm9sOiB0aGlzLnJlbmRlckNvbnRyb2wsXG4gICAgICAgICAgICAgICAgcmVuZGVyVG9vbGJhcjogdGhpcy5yZW5kZXJUb29sQmFyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IHRoaXMuZGFzaGJvYXJkX3JlZixcbiAgICAgICAgICAgICAgICBzdHlsZTogZGl2U3R5bGVcbiAgICAgICAgICAgIH0sIHRoaXMucmVuZGVyQ29udHJvbCgocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgbGV0IHsgY29udHJvbFByb3AgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbFByb3AuY29udHJvbFBvc2l0aW9uICE9PSBcImJvdHRvbVwiO1xuICAgICAgICAgICAgfSksIHRoaXMucmVuZGVyQ2hhcnQoKSwgdGhpcy5yZW5kZXJDb250cm9sKChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250cm9sUHJvcCAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sUHJvcC5jb250cm9sUG9zaXRpb24gPT09IFwiYm90dG9tXCI7XG4gICAgICAgICAgICB9KSwgdGhpcy5yZW5kZXJUb29sQmFyKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MxKXtcbiAgICAgICAgdmFyIF90aGlzMTtcbiAgICAgICAgc3VwZXIoLi4uYXJnczEpLCBfdGhpczEgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRXcmFwcGVyOiBudWxsLFxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnREYXNoYm9hcmQ6IG51bGwsXG4gICAgICAgICAgICBnb29nbGVDaGFydENvbnRyb2xzOiBudWxsLFxuICAgICAgICAgICAgZ29vZ2xlQ2hhcnRFZGl0b3I6IG51bGwsXG4gICAgICAgICAgICBpc1JlYWR5OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdyYXBoSUQgPSBudWxsO1xuICAgICAgICB0aGlzLmRhc2hib2FyZF9yZWYgPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnRvb2xiYXJfcmVmID0gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5nZXRHcmFwaElEID0gKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgZ3JhcGhJRCAsIGdyYXBoX2lkICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZUdyYXBoSUQ7XG4gICAgICAgICAgICBpZiAoIWdyYXBoSUQgJiYgIWdyYXBoX2lkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdyYXBoSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VHcmFwaElEID0gZ2VuZXJhdGVVbmlxdWVJRCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlR3JhcGhJRCA9IHRoaXMuZ3JhcGhJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdyYXBoSUQgJiYgIWdyYXBoX2lkKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VHcmFwaElEID0gZ3JhcGhJRDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JhcGhfaWQgJiYgIWdyYXBoSUQpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUdyYXBoSUQgPSBncmFwaF9pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VHcmFwaElEID0gZ3JhcGhJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3JhcGhJRCA9IGluc3RhbmNlR3JhcGhJRDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyYXBoSUQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29udHJvbElEID0gKGlkLCBpbmRleCk9PntcbiAgICAgICAgICAgIGNvbnRyb2xDb3VudGVyICs9IDE7XG4gICAgICAgICAgICBsZXQgY29udHJvbElEO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xJRCA9IFwiZ29vZ2xlY2hhcnQtY29udHJvbC1cIi5jb25jYXQoaW5kZXgsIFwiLVwiKS5jb25jYXQoY29udHJvbENvdW50ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250cm9sSUQgPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250cm9sSUQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkQ29udHJvbHMgPSAoZ29vZ2xlQ2hhcnRXcmFwcGVyLCBnb29nbGVDaGFydERhc2hib2FyZCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgZ29vZ2xlICwgY29udHJvbHMgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgZ29vZ2xlQ2hhcnRDb250cm9scyA9ICFjb250cm9scyA/IG51bGwgOiBjb250cm9scy5tYXAoKGNvbnRyb2wsIGkpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb250cm9sSUQ6IGNvbnRyb2xJRE1heWJlICwgY29udHJvbFR5cGUgLCBvcHRpb25zOiBjb250cm9sT3B0aW9ucyAsIGNvbnRyb2xXcmFwcGVyUGFyYW1zICwgIH0gPSBjb250cm9sO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xJRCA9IHRoaXMuZ2V0Q29udHJvbElEKGNvbnRyb2xJRE1heWJlLCBpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sUHJvcDogY29udHJvbCxcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbDogbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkNvbnRyb2xXcmFwcGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcklkOiBjb250cm9sSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNvbnRyb2xPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29udHJvbFdyYXBwZXJQYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWdvb2dsZUNoYXJ0Q29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdvb2dsZUNoYXJ0RGFzaGJvYXJkLmJpbmQoZ29vZ2xlQ2hhcnRDb250cm9scy5tYXAoKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIGxldCB7IGNvbnRyb2wgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbDtcbiAgICAgICAgICAgIH0pLCBnb29nbGVDaGFydFdyYXBwZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hhcnRDb250cm9sIG9mIGdvb2dsZUNoYXJ0Q29udHJvbHMpe1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29udHJvbCAsIGNvbnRyb2xQcm9wICB9ID0gY2hhcnRDb250cm9sO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29udHJvbEV2ZW50cyA9W10gIH0gPSBjb250cm9sUHJvcDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBldmVudCBvZiBjb250cm9sRXZlbnRzKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjYWxsYmFjayAsIGV2ZW50TmFtZSAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMucmVtb3ZlTGlzdGVuZXIoY29udHJvbCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS52aXN1YWxpemF0aW9uLmV2ZW50cy5hZGRMaXN0ZW5lcihjb250cm9sLCBldmVudE5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnRXcmFwcGVyOiBnb29nbGVDaGFydFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbFdyYXBwZXI6IGNvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvb2dsZTogZ29vZ2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXJnczogYXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnb29nbGVDaGFydENvbnRyb2xzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmRlckNoYXJ0ID0gKCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGggLCBoZWlnaHQgLCBvcHRpb25zICwgc3R5bGUgLCBjbGFzc05hbWUgLCByb290UHJvcHMgLCBnb29nbGUgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgZGl2U3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgfHwgb3B0aW9ucyAmJiBvcHRpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggfHwgb3B0aW9ucyAmJiBvcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgIC4uLnN0eWxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5nZXRHcmFwaElEKCksXG4gICAgICAgICAgICAgICAgc3R5bGU6IGRpdlN0eWxlLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICAgICAgICB9LCByb290UHJvcHMpLCB0aGlzLnN0YXRlLmlzUmVhZHkgJiYgdGhpcy5zdGF0ZS5nb29nbGVDaGFydFdyYXBwZXIgIT09IG51bGwgPyAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChHb29nbGVDaGFydERhdGFUYWJsZSwge1xuICAgICAgICAgICAgICAgIGdvb2dsZUNoYXJ0V3JhcHBlcjogdGhpcy5zdGF0ZS5nb29nbGVDaGFydFdyYXBwZXIsXG4gICAgICAgICAgICAgICAgZ29vZ2xlOiBnb29nbGUsXG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2hhcnREYXNoYm9hcmQ6IHRoaXMuc3RhdGUuZ29vZ2xlQ2hhcnREYXNoYm9hcmRcbiAgICAgICAgICAgIH0pLCAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR29vZ2xlQ2hhcnRFdmVudHMsIHtcbiAgICAgICAgICAgICAgICBnb29nbGVDaGFydFdyYXBwZXI6IHRoaXMuc3RhdGUuZ29vZ2xlQ2hhcnRXcmFwcGVyLFxuICAgICAgICAgICAgICAgIGdvb2dsZTogZ29vZ2xlXG4gICAgICAgICAgICB9KSkgOiBudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXJDb250cm9sID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgZmlsdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMS5zdGF0ZS5pc1JlYWR5ICYmIF90aGlzMS5zdGF0ZS5nb29nbGVDaGFydENvbnRyb2xzICE9PSBudWxsID8gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBfdGhpczEuc3RhdGUuZ29vZ2xlQ2hhcnRDb250cm9scy5maWx0ZXIoKHBhcmFtKT0+e1xuICAgICAgICAgICAgICAgIGxldCB7IGNvbnRyb2xQcm9wICwgY29udHJvbCAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sUHJvcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkubWFwKChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250cm9sICwgY29udHJvbFByb3AgIH0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBjb250cm9sLmdldENvbnRhaW5lcklkKCksXG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb250cm9sLmdldENvbnRhaW5lcklkKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyVG9vbEJhciA9ICgpPT57XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvcHMudG9vbGJhckl0ZW1zKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgIHJlZjogdGhpcy50b29sYmFyX3JlZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBDaGFydCQxIGV4dGVuZHMgKFJlYWN0LkNvbXBvbmVudCkge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjaGFydExhbmd1YWdlICwgY2hhcnRQYWNrYWdlcyAsIGNoYXJ0VmVyc2lvbiAsIG1hcHNBcGlLZXkgLCBsb2FkZXIgLCBlcnJvckVsZW1lbnQgLCAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5wcm9wc1xuICAgICAgICB9LCB0aGlzLnN0YXRlLmxvYWRpbmdTdGF0dXMgPT09IFwicmVhZHlcIiAmJiB0aGlzLnN0YXRlLmdvb2dsZSAhPT0gbnVsbCA/IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChHb29nbGVDaGFydCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgICAgICAgZ29vZ2xlOiB0aGlzLnN0YXRlLmdvb2dsZVxuICAgICAgICB9KSkgOiB0aGlzLnN0YXRlLmxvYWRpbmdTdGF0dXMgPT09IFwiZXJyb3JlZFwiICYmIGVycm9yRWxlbWVudCA/IGVycm9yRWxlbWVudCA6IGxvYWRlciwgLyojX19QVVJFX18qLyBSZWFjdC5jcmVhdGVFbGVtZW50KExvYWRHb29nbGVDaGFydHMsIHtcbiAgICAgICAgICAgIGNoYXJ0TGFuZ3VhZ2U6IGNoYXJ0TGFuZ3VhZ2UsXG4gICAgICAgICAgICBjaGFydFBhY2thZ2VzOiBjaGFydFBhY2thZ2VzLFxuICAgICAgICAgICAgY2hhcnRWZXJzaW9uOiBjaGFydFZlcnNpb24sXG4gICAgICAgICAgICBtYXBzQXBpS2V5OiBtYXBzQXBpS2V5LFxuICAgICAgICAgICAgb25Mb2FkOiB0aGlzLm9uTG9hZCxcbiAgICAgICAgICAgIG9uRXJyb3I6IHRoaXMub25FcnJvclxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlzRnVsbHlMb2FkZWQoZ29vZ2xlKSB7XG4gICAgICAgIGNvbnN0IHsgY29udHJvbHMgLCB0b29sYmFySXRlbXMgLCBnZXRDaGFydEVkaXRvciAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiBnb29nbGUgJiYgZ29vZ2xlLnZpc3VhbGl6YXRpb24gJiYgZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyICYmIGdvb2dsZS52aXN1YWxpemF0aW9uLkRhc2hib2FyZCAmJiAoIWNvbnRyb2xzIHx8IGdvb2dsZS52aXN1YWxpemF0aW9uLkNoYXJ0V3JhcHBlcikgJiYgKCFnZXRDaGFydEVkaXRvciB8fCBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydEVkaXRvcikgJiYgKCF0b29sYmFySXRlbXMgfHwgZ29vZ2xlLnZpc3VhbGl6YXRpb24uZHJhd1Rvb2xiYXIpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgbG9hZGluZ1N0YXR1czogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgICBnb29nbGU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkxvYWQgPSAoZ29vZ2xlMSk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKGdvb2dsZTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNGdWxseUxvYWRlZChnb29nbGUxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25TdWNjZXNzKGdvb2dsZTEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJRTExOiB3aW5kb3cuZ29vZ2xlIGlzIG5vdCBmdWxseSBzZXQsIHdlIGhhdmUgdG8gd2FpdFxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gc2V0SW50ZXJ2YWwoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ29vZ2xlID0gd2luZG93Lmdvb2dsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdvb2dsZSAmJiB0aGlzLmlzRnVsbHlMb2FkZWQoZ29vZ2xlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TdWNjZXNzKGdvb2dsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU3VjY2VzcyA9IChnb29nbGUpPT57XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nU3RhdHVzOiBcInJlYWR5XCIsXG4gICAgICAgICAgICAgICAgZ29vZ2xlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkVycm9yID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGxvYWRpbmdTdGF0dXM6IFwiZXJyb3JlZFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5DaGFydCQxLmRlZmF1bHRQcm9wcyA9IGNoYXJ0RGVmYXVsdFByb3BzO1xuXG52YXIgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGU7XG4oZnVuY3Rpb24oR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGUpIHtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcImFubm90YXRpb25cIl0gPSBcImFubm90YXRpb25cIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcImFubm90YXRpb25UZXh0XCJdID0gXCJhbm5vdGF0aW9uVGV4dFwiO1xuICAgIEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlW1wiY2VydGFpbnR5XCJdID0gXCJjZXJ0YWludHlcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcImVtcGhhc2lzXCJdID0gXCJlbXBoYXNpc1wiO1xuICAgIEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlW1wiaW50ZXJ2YWxcIl0gPSBcImludGVydmFsXCI7XG4gICAgR29vZ2xlRGF0YVRhYmxlQ29sdW1uUm9sZVR5cGVbXCJzY29wZVwiXSA9IFwic2NvcGVcIjtcbiAgICBHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZVtcInN0eWxlXCJdID0gXCJzdHlsZVwiO1xuICAgIEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlW1widG9vbHRpcFwiXSA9IFwidG9vbHRpcFwiO1xuICAgIEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlW1wiZG9tYWluXCJdID0gXCJkb21haW5cIjtcbn0pKEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlIHx8IChHb29nbGVEYXRhVGFibGVDb2x1bW5Sb2xlVHlwZSA9IHt9KSk7XG5cbnZhciBDaGFydCA9IENoYXJ0JDE7XG5cbmV4cG9ydCB7IENoYXJ0JDEgYXMgQ2hhcnQsIEdvb2dsZURhdGFUYWJsZUNvbHVtblJvbGVUeXBlLCBDaGFydCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-google-charts/dist/index.js\n");

/***/ })

};
;